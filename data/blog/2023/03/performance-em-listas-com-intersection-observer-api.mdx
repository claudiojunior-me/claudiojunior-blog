---
title: Por que o useEffect n√£o est√° ativando? Como funcionam as compara√ß√µes no useEffect
date: '2023-03-04'
draft: false
canonicalUrl: '/posts/como-funcionam-comparacoes-useEffect'
authors: ['default']
tags: ['react', 'javascript']
summary: 'A compara√ß√£o de depend√™ncias no useEffect √© crucial para garantir que o efeito seja executado apenas quando for necess√°rio, evitando assim, comportamentos indesejados e melhorando a performance. Mas e quando temos um objeto complexo e essa compara√ß√£o n√£o retorna a resposta desejada?'
---

Os hooks do React s√£o de fato uma m√£o na roda, por√©m, vez ou outra, acabamos passando por alguns perrenges em que olhamos, olhamos e olhamos pro c√≥digo
e n√£o descobrimos nem sobre o que procurar, porque, de fato, n√£o parece ter nada errado com a implementa√ß√£o, mas ainda sim nada de funcionar
da maneira que esper√°vamos. √â nesses momentos que acabamos nos aprofundando mais nas implementa√ß√£o das libs que usamos no nosso dia a dia, e
isso nos tr√°s diversas descobertas.

---

O `useEffect` √© um dos hooks mais utilizados no React, e nos permite que adicionemos efeitos colaterais a componentes funcionais.
Uma das funcionalidades mais importantes do `useEffect` √© a possibilidade de definir depend√™ncias, que s√£o valores que, quando alterados,
devem fazer com que o efeito seja executado novamente.

A compara√ß√£o de depend√™ncias no `useEffect` √© crucial para garantir que o efeito seja executado apenas quando for necess√°rio, evitando
assim, comportamentos indesejados e melhorando a performance. Quando as depend√™ncias s√£o definidas, o React compara os valores antigos e
os novos para decidir se o efeito deve ser executado novamente.

Por√©m algoritmo de compara√ß√£o padr√£o do React √© chamado de **"compara√ß√£o rasa"** ou **"shallow comparison"**. Na compara√ß√£o rasa, o React
compara apenas as refer√™ncias de objetos e verifica se elas s√£o id√™nticas. Isso significa que, mesmo que o conte√∫do do objeto seja alterado,
se a refer√™ncia permanecer a mesma, o React considerar√° que o valor n√£o mudou e n√£o executar√° o efeito.

Isso pode levar a comportamentos indesejados quando trabalhamos com objetos complexos, como arrays ou objetos aninhados.
Se alterarmos o conte√∫do do objeto sem modificar sua refer√™ncia, o efeito n√£o ser√° executado novamente.
Para resolver esse problema, podemos usar uma **"compara√ß√£o profunda"** ou **"deep comparison"**.

Na compara√ß√£o profunda, o React verifica se o conte√∫do do objeto √© igual, independentemente de sua refer√™ncia. Isso
permite que o efeito seja executado novamente sempre que o valor √© modificado, independentemente de como ele foi modificado.

Para usar uma compara√ß√£o profunda no `useEffect`, podemos usar bibliotecas como o `lodash` ou o `fast-deep-equal` para criarmos nossa pr√≥pria implementa√ß√£o
do `useEffect`:

```javascript
import { useRef, useEffect } from 'react'
import isEqual from 'lodash/isEqual'

function useDeepCompareMemoize(value) {
  const ref = useRef()

  if (!isEqual(value, ref.current)) {
    ref.current = value
  }

  return ref.current
}

function useDeepCompareEffect(callback, dependencies) {
  useEffect(
    callback,
    dependencies.map(useDeepCompareMemoize)
  )
}

export useDeepCompareEffect

// para utilizar, basta usar como se fosse o pr√≥prio useEffect:
// useDeepCompareEffect(() => {}, [deepDependence1, deepDependence2.items])
```

Em geral, √© recomendado usar uma compara√ß√£o profunda quando trabalhamos com objetos complexos, como arrays ou objetos aninhados.
No entanto, √© importante lembrar que a compara√ß√£o profunda pode ser mais intensiva em termos de performance do que a compara√ß√£o rasa,
especialmente quando trabalhamos com objetos grandes ou profundamente aninhados. Portanto, √© importante avaliar a necessidade
de uma compara√ß√£o profunda em cada caso e considerar o impacto na performance do aplicativo.

---

Em um pr√≥ximo post pretendo abordar mais a fundo at√© onde vai a compara√ß√£o rasa e como funcionam as compara√ß√µes no javascript.

üòé
