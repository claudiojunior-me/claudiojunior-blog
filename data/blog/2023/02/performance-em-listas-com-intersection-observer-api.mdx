---
title: Entregando mais performance em listas usando a Intersection Observer API
date: '2023-02-21'
draft: false
canonicalUrl: '/posts/performance-em-listas-com-intersection-observer-api'
authors: ['default']
tags: ['react', 'javascript']
summary: 'Voc√™ sabia que o Intersection Observer API pode ajudar a melhorar o desempenho do seu site? üöÄüëÄ Essa API do navegador permite detectar facilmente se um elemento HTML est√° vis√≠vel no viewport ou n√£o, sem afetar negativamente a experi√™ncia do usu√°rio.'
---

Primeiramente, um breve resumo do problema que me fez encontrar e aplicar a Intersection Observer:

---

Pra quem n√£o sabe, no momento, trabalho em um e-commerce B2B (empresa vendendo para empresa, basicamente), e, como todo e-commerce, temos uma √°rea de visualiza√ß√£o de pedidos j√° realizados.

Essa √°rea at√© possui uma pagina√ß√£o para carregar os dados junto a API, por√©m, em tela, as p√°ginas s√£o carregadas uma abaixo da outra, por exemplo:

P√°gina abre mostrando 10 pedidos, em cada card de pedido √© exibido um resumo do mesmo - em qual etapa que se encontra (_nota fiscal_, _pagamento_, _em rota_, _etc_) al√©m de possuir tamb√©m uma breve visualiza√ß√£o dos produtos contidos no pedido.

Quando pedimos para carregar mais pedidos, mais 10 pedidos s√£o concatenados nessa lista, e assim segue, essa lista crescendo conforme se clica para carregar os √∫ltimos pedidos - _**MAS**, antes de parecer totalmente loucura, existe tamb√©m uma pesquisa por pedidos, ent√£o n√£o precisa sair sempre carregando mais e mais at√© chegar em um pedido feito h√° 1 ano, kkkkk_.

O problema era, a partir de certa quantidade de itens na carregados, o site come√ßava a apresentar uma queda not√°vel de performance, no scroll, um aumento de consumo de recursos do browser, todos os sintomas de um problema de renderiza√ß√£o de listas grandes.

Como utilizamos o React + Next JS como stack, procuramos algo dentro do pr√≥prio ecossistema React para resolver isso. Inclusive, encontrei uma lib que resolveria o problema, por√©m, pra implementar da maneira que nos seria satisfat√≥rio, ela exigiria instalar outra lib complementar, e eu sou um pouco relutante a inserir libs em demasiado nos projetos.

Foi ai que encontrei algo j√° nativo nos browser em que precisamos suportar, n√£o dependia de uma lib externa e aparentemente resolveria nosso problema, a Intersection Observer API.

---

## O que √© a Intersection Observer API?

A [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) √© uma API do navegador que permite observar mudan√ßas na interse√ß√£o entre um elemento HTML e o viewport (a √°rea vis√≠vel na janela do navegador). Ele fornece uma maneira eficiente de monitorar se um elemento est√° vis√≠vel no viewport ou n√£o e, em seguida, executar uma a√ß√£o com base nessa informa√ß√£o.

> A √°rea de intersec√ß√£o do navegador, tamb√©m conhecida como viewport, √© a regi√£o vis√≠vel da janela do navegador em um determinado momento, essa √© a √°rea da p√°gina em que o usu√°rio pode ver e interagir diretamente. Essa √°rea pode variar de acordo com a resolu√ß√£o do monitor e o tamanho da janela do navegador.> A √°rea de intersec√ß√£o do navegador, tamb√©m conhecida como viewport, √© a regi√£o vis√≠vel da janela do navegador em um determinado momento, essa √© a √°rea da p√°gina em que o usu√°rio pode ver e interagir diretamente. Essa √°rea pode variar de acordo com a resolu√ß√£o do monitor e o tamanho da janela do navegador.

## Quais as vantagens em usar a Intersection Observer API?

- **Melhor desempenho**: O uso do Intersection Observer API pode melhorar o desempenho do seu site, pois ele pode reduzir a quantidade de trabalho que o navegador precisa fazer para detectar a visibilidade dos elementos na p√°gina. O navegador pode detectar automaticamente quando os elementos se tornam vis√≠veis ou saem da tela, sem a necessidade de calcular manualmente as coordenadas dos elementos ou usar m√©todos mais intensivos em recursos, como o `scroll` ou `resize`.

- **Compatibilidade**: O Intersection Observer API √© suportado por todos os principais navegadores modernos, incluindo o Chrome, Firefox, Safari e Edge.

- **Funcionalidade avan√ßada**: Com ela √© capaz, por exemplo, de executar alguma fun√ß√£o, carregamento de dados, ou coisas do tipo apenas quando o elemento em quest√£o entrar na √°rea de intersec√ß√£o do navegador.

## Como implementar?

Para come√ßar a usar o Intersection Observer API, voc√™ precisa criar um novo objeto `IntersectionObserver` e passar uma fun√ß√£o de retorno de chamada para ser executada sempre que a interse√ß√£o entre o elemento observado e o viewport mudar. Essa fun√ß√£o de retorno de chamada receber√° um array de objetos `IntersectionObserverEntry` como seu √∫nico argumento, que cont√©m informa√ß√µes sobre a interse√ß√£o entre o elemento observado e o viewport.

```javascript
const options = {
  root: null,
  threshold: 0.5,
}

const observer = new IntersectionObserver((entries) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      console.log('Element is visible in the viewport')
    } else {
      console.log('Element is NOT visible in the viewport')
    }
  })
}, options)

const elementToObserve = document.querySelector('#element-to-observe')
observer.observe(elementToObserve)
```

Neste exemplo, estamos observando se o elemento `#element-to-observe` est√° vis√≠vel no viewport, e, assim que estiver, ele ir√° printar a mensagem `'Element is visible in the viewport'`.

Nele criamos um novo objeto `IntersectionObserver` e passamos uma fun√ß√£o de retorno de chamada para ser executada sempre que a interse√ß√£o entre o elemento observado e o viewport mudar. O m√©todo `observe` do objeto `IntersectionObserver` √© o respons√°vel por come√ßar a observar as mudan√ßas de interse√ß√£o entre esses elementos.

No callback verificamos se o elemento observado est√° vis√≠vel no viewport ou n√£o usando a propriedade `isIntersecting` do objeto `IntersectionObserverEntry`.

```javascript
function useIntersectionItem(containerSelector) {
  const [loaded, setLoaded] = useState(false)
  const elRef = useRef()

  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setLoaded(true)
            observer.disconnect()
          } else {
            setLoaded(false)
          }
        })
      },
      { root: document.querySelector(containerSelector) }
    )

    observer.observe(elRef.current)
  }, [])

  return { loaded, elRef }
}

function HeavyItemOfList() {
  const { loaded, elRef } = useLoadHeavyItem('#list-container')

  return <div ref={elRef}>{loaded ? <p>Not Loaded</p> : <p>Loaded</p>}</div>
}
```

J√° nesse exemplo, utilizando React, criamos um hook e utilizamos ele para observar a intersec√ß√£o entre um item de uma lista e o viewport do componente utilizado como container dessa lista.

Para este exemplo fazemos o uso do m√©todo `disconnect` do `IntersectionObserver` para que, assim tenha acontecido a intersec√ß√£o uma vez, o `IntersectionObserver` para de ficar observando novas altera√ß√µes para esse elemento.

### Op√ß√µes de configura√ß√£o do Intersection Observer API

O `IntersectionObserver` aceita algumas op√ß√µes de configura√ß√£o opcionais para ajustar seu comportamento:

- `root¬¥: define o elemento que √© usado como viewport para o observador de interse√ß√£o. O valor padr√£o √© o `viewport` do navegador.
- `rootMargin`: define uma margem em torno do viewport, o que pode ser √∫til para ajustar o comportamento do observador de interse√ß√£o. _O valor padr√£o √© `"0px 0px 0px 0px"`_.
- `threshold`: define o limiar de interse√ß√£o para o observador de interse√ß√£o. _O valor padr√£o √© 0_.

---

üòé
